ADC   ,0xA9 ,1 // IMM ii
ADC   ,0xB9 ,1 // DIR dd - direct addressing 
ADC   ,0xC9 ,2 // EXT hh ll - extended direct addressing
ADC   ,0xD9 ,2 // IX2 ee ff - indexed 16 bit
ADC   ,0xE9 ,1 // IX1 ff - indexed 8 bit
ADC   ,0xF9 ,0 // IX - indexed no offset

ADD   ,0xAB ,1 // IMM ii - immidiate value woot
ADD   ,0xBB ,1 // DIR dd - direct addressing 
ADD   ,0xCB ,2 // EXT hh ll 
ADD   ,0xDB ,2 // IX2 ee ff
ADD   ,0xEB ,1 // IX1 ff
ADD   ,0xFB ,0 // IX

AND   ,0xA4 ,1 // IMM ii - immidiate value woot
AND   ,0xB4 ,1 // DIR dd - direct addressing 
AND   ,0xC4 ,2 // EXT hh ll 
AND   ,0xD4 ,2 // IX2 ee ff
AND   ,0xE4 ,1 // IX1 ff
AND   ,0xF4 ,0 // IX

ASL   ,0x38 ,1 // DIR dd
ASLA  ,0x48 ,0 // INH
ASLX  ,0x58 ,0 // INH
ASL   ,0x68 ,1 // IX1 ff
ASL   ,0x78 ,0 // IX 

ASR   ,0x37 ,1 // DIR dd
ASRA  ,0x47 ,0 // INH
ASRX  ,0x57 ,0 // INH
ASR   ,0x67 ,1 // IX1 ff 
ASR   ,0x77 ,0 // IX

BCC   ,0x24 ,1

BCLR  ,0x11 ,1
BCLR ,0x13 ,1
BCLR ,0x15 ,1
BCLR ,0x17 ,1
BCLR ,0x19 ,1
BCLR ,0x1B ,1
BCLR ,0x1D ,1
BCLR ,0x1F ,1

BCS   ,0x25 ,1
BEQ   ,0x27 ,1
BHCC  ,0x28 ,1
BHCS  ,0x29 ,1
BHI   ,0x21 ,1
BHS   ,0x24 ,1
BIH   ,0x2F ,1
BIL   ,0x2E ,1

BIT   ,0xA5 ,1 // IMM ii
BIT   ,0xB5 ,1 // DIR dd
BIT   ,0xC5 ,2 // EXT hh ll
BIT   ,0xD5 ,2 // IX2 ee ff
BIT   ,0xE5 ,1 // IX1 ff
BIT   ,0xF5 ,0 // IX

BLO   ,0x25 ,1
BLS   ,0x23 ,1
BMC   ,0x2C ,1
BMI   ,0x2B ,1
BMS   ,0x2D ,1
BNE   ,0x26 ,1
BPL   ,0x2A ,1
BRA   ,0x20 ,1
BRN   ,0x21 ,1

BRCLR ,0x01 ,1|1
BRCLR ,0x03 ,1|1
BRCLR ,0x05 ,1|1
BRCLR ,0x07 ,1|1
BRCLR ,0x09 ,1|1
BRCLR ,0x0B ,1|1
BRCLR ,0x0D ,1|1
BRCLR ,0x0F ,1|1

BRSET ,0x00 ,1|1
BRSET ,0x02 ,1|1
BRSET ,0x04 ,1|1
BRSET ,0x06 ,1|1
BRSET ,0x08 ,1|1
BRSET ,0x0A ,1|1
BRSET ,0x0C ,1|1
BRSET ,0x0E ,1|1

BSET ,0x10 ,1
BSET ,0x12 ,1
BSET ,0x14 ,1
BSET ,0x16 ,1
BSET ,0x18 ,1
BSET ,0x1A ,1
BSET ,0x1C ,1
BSET ,0x1E ,1

BSR   ,0xAD ,1
CLC   ,0x98 ,0
CLI   ,0x9A ,0

CLR   ,0x3F ,1 // DIR dd
CLRA  ,0x4F ,0 // INH 
CLRX  ,0x5F ,0 // INH
CLR   ,0x6F ,1 // IX1 ff
CLR   ,0x7F ,0 // IX

CMP   ,0xA1 ,1 // IMM ii
CMP   ,0xB1 ,1 // DIR dd
CMP   ,0xC1 ,2 // EXT hh ll
CMP   ,0xD1 ,2 // IX2 ee ff
CMP   ,0xE1 ,1 // IX1 ff
CMP   ,0xF1 ,0 // IX

COM   ,0x33 ,1 //DIR dd
COMA  ,0x43 ,0 // INH
COMX  ,0x53 ,0 // INH
COM   ,0x63 ,1 // IX1
COM   ,0x73 ,0 //IX

CPX   ,0xA3 ,1 // IMM ii
CPX   ,0xB3 ,1 // DIR dd
CPX   ,0xC3 ,2 // EXT hh ll
CPX   ,0xD3 ,2 // IX2 ee ff
CPX   ,0xE3 ,1 // IX1 ff
CPX   ,0xF3 ,0 // IX

DEC   ,0x3A ,1 // DIR dd
DECA  ,0x4A ,0 // INH
DECX  ,0x5A ,0 // INH
DEC   ,0x6A ,1 // IX1 ff
DEC   ,0x7A ,0 // IX

EOR   ,0xA8 ,1 // IMM ii
EOR   ,0xB8 ,1 // DIR dd
EOR   ,0xC8 ,2 // EXT hh ll
EOR   ,0xD8 ,2 // IX2 ee ff
EOR   ,0xE8 ,1 // IX1 ff
EOR   ,0xF8 ,0 // IX

INC   ,0x3C ,1 // DIR dd
INCA  ,0x4C ,0 // INH
INCX  ,0x5C ,0 // INH
INC   ,0x6C ,1 // IX1 ff
INC   ,0x7C ,0 // IX

JMP   ,0xBC ,1 // DIR dd
JMP   ,0xCC ,2 // EXT hh ll
JMP   ,0xDC ,2 // IX2 ee ff indexed 16
JMP   ,0xEC ,1 // IX1 ff
JMP   ,0xFC ,0 // IX 

JSR   ,0xBD ,1 // DIR dd    direct mode
JSR   ,0xCD ,2 // EXT hh ll extended mode
JSR   ,0xDD ,2 // IX2 ee ff Indexed, 16-bit offset addressing mode
JSR   ,0xED ,1 // IX1 ff    Indexed, 8-bit offset addressing mode
JSR   ,0xFD ,0 // IX        Indexed, no offset addressing mode          

LDA   ,0xA6 ,1 // IMM ii
LDA   ,0xB6 ,1 // DIR dd
LDA   ,0xC6 ,2 // EXT hh ll
LDA   ,0xD6 ,2 // IX2 ee ff
LDA   ,0xE6 ,1 // IX1 ff
LDA   ,0xF6 ,1 // IX

LDX   ,0xAE ,1 // IMM ii
LDX   ,0xBE ,1 // DIR dd
LDX   ,0xCE ,2 // EXT hh ll
LDX   ,0xDE ,2 // IX2 ee ff
LDX   ,0xEE ,1 // IX1 ff
LDX   ,0xFE ,1 // IX

LSL   ,0x38 ,1 // DIR dd
LSLA  ,0x48 ,0 // INH
LSLX  ,0x58 ,0 // INH
LSL   ,0x68 ,1 // IX1 ff
LSL   ,0x78 ,0 // IX

LSR   ,0x34 ,1 // DIR dd
LSRA  ,0x44 ,0 // INH
LSRX  ,0x54 ,0 // INH
LSR   ,0x64 ,1 // IX1 ff
LSR   ,0x74 ,0 // IX

NEG   ,0x30 ,1 // DIR dd
NEGA  ,0x40 ,0 // INH
NEGX  ,0x50 ,0 // INH
NEG   ,0x60 ,1 // IX1 ff
NEG   ,0x70 ,1 // IX

NOP   ,0x9D ,0

ORA   ,0xAA ,1 // IMM ii
ORA   ,0xBA ,1 // DIR dd
ORA   ,0xCA ,2 // EXT hh ll
ORA   ,0xDA ,2 // IX2 ee ff
ORA   ,0xEA ,1 // IX1 ff
ORA   ,0xFA ,0 // IX

ROL   ,0x39 ,1 // DIR dd
ROLA  ,0x49 ,0 // INH
ROLX  ,0x59 ,0 // INH
ROL   ,0x69 ,1 // IX1 ff
ROL   ,0x79 ,0 // IX

ROR   ,0x36 ,1 // DIR dd
RORA  ,0x46 ,0 // INH
RORX  ,0x56 ,0 // INH
ROR   ,0x66 ,1 // IX1 ff
ROR   ,0x76 ,0 // IX

RSP   ,0x9C ,0
RTI   ,0x80 ,0
RTS   ,0x81 ,0

SBC   ,0xA2 ,1 // IMM ii
SBC   ,0xB2 ,1 // DIR dd
SBC   ,0xC2 ,2 // EXT hh ll
SBC   ,0xD2 ,2 // IX2 ee ff
SBC   ,0xE2 ,1 // IX1 ff
SBC   ,0xF2 ,0 // IX

SEC   ,0x99 ,0
SEI   ,0x9B ,0

STA   ,0xB7 ,1 // DIR dd
STA   ,0xC7 ,2 // EXT hh ll
STA   ,0xD7 ,2 // IX2 ee ff
STA   ,0xE7 ,1 // IX1 ff
STA   ,0xF7 ,0 // IX

STOP  ,0x8E ,0 //INH

STX   ,0xBF ,1 // DIR dd
STX   ,0xCF ,2 // EXT hh ll
STX   ,0xDF ,2 // IX2 ee ff
STX   ,0xEF ,1 // IX1 ff
STX   ,0xFF ,0 // IX

SUB   ,0xA0 ,1 // IMM ii
SUB   ,0xB0 ,1 // DIR dd
SUB   ,0xC0 ,2 // EXT hh ll
SUB   ,0xD0 ,2 // IX2 ee ff
SUB   ,0xE0 ,1 // IX1 ff
SUB   ,0xF0 ,0 // IX

SWI   ,0x83 ,0 //INH
TAX   ,0x97 ,0 //INH

TST   ,0x3D ,1 // DIR dd
TSTA  ,0x4D ,0 // INH
TSTX  ,0x5D ,0 // INH
TST   ,0x6D ,1 // IX1 ff
TST   ,0x7D ,0 // IX

TXA   ,0x9F ,0 //INH
WAIT  ,0x8F ,0 //INH

// IX - Indexed instructions with no offset are 1-byte instructions that can access data with variable addresses
//      within the first 256 memory locations. The index register contains the low byte of the effective address of
//      the operand. The CPU automatically uses $00 as the high byte, so these instructions can address
//      locations $0000–$00FF.
//      Indexed, no offset instructions are often used to move a pointer through a table or to hold the address of
//      a frequently used random-access memory (RAM) or input/output (I/O) locatio
// IX1 - Indexed, 8-bit offset instructions are 2-byte instructions that can access data with variable addresses
//      within the first 511 memory locations. The CPU adds the unsigned byte in the index register to the
//      unsigned byte following the opcode. The sum is the effective address of the operand. These instructions
//      can access locations $0000–$01FE.
//      Indexed 8-bit offset instructions are useful for selecting the kth element in an n-element table. The table
//      can begin anywhere within the first 256 memory locations and could extend as far as location 510
//      ($01FE). The k value is typically in the index register, and the address of the beginning of the table is in
//      the byte following the opcode.
// IX2 - Indexed, 16-bit offset instructions are 3-byte instructions that can access data with variable addresses at
//      any location in memory. The CPU adds the unsigned byte in the index register to the two unsigned bytes
//      following the opcode. The sum is the effective address of the operand. The first byte after the opcode is
//      the high byte of the 16-bit offset; the second byte is the low byte of the offset.
//      Indexed, 16-bit offset instructions are useful for selecting the kth element in an n-element table anywhere
//      in memory.
//      As with direct and extended addressing, the Freescale assembler determines the shortest form of
//      indexed addressing.
// REL - Relative addressing is only for branch instructions. If the branch condition is true, the CPU finds the
//       effective branch destination by adding the signed byte following the opcode to the contents of the program
//       counter. If the branch condition is not true, the CPU goes to the next instruction. The offset is a signed,
//       two’s complement byte that gives a branching range of –128 to +127 bytes from the address of the next
//       location after the branch instruction.
//       When using the Freescale assembler, the programmer does not need to calculate the offset, because the
//       assembler determines the proper offset and verifies that it is within the span of the branch.
// EXT - Extended instructions use three bytes and can access any address in memory. The first byte is the
//       opcode; the second and third bytes are the high and low bytes of the operand address.
//       When using the Freescale assembler, the programmer does not need to specify whether an instruction is
//       direct or extended. The assembler automatically selects the shortest form of the instruction.
// IMM - Immediate instructions are those that contain a value to be used in an operation with the value in the
//       accumulator or index register. Immediate instructions require no operand address and are two bytes long.
//       The opcode is the first byte, and the immediate data value is the second byte.
// INH - Inherent instructions are those that have no operand, such as return from interrupt (RTI) and stop (STOP).
//       Some of the inherent instructions act on data in the CPU registers, such as set carry flag (SEC) and
//       increment accumulator (INCA). Inherent instructions require no operand address and are one byte long.
// DIR - Direct instructions can access any of the first 256 memory locations with two bytes. The first byte is the
//       opcode, and the second is the low byte of the operand address. In direct addressing, the CPU
//       automatically uses $00 as the high byte of the operand address.
